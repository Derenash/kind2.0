Kind.load
: ∀(name: String)
  (IO Kind.Book)
= λname
  let book = (String.Map.new Kind.Term)
  (Kind.load.name name book)

// Loads a file into a book
Kind.load.code
: ∀(name: String)
  (IO Kind.Book)
= λname
  (IO.load Kind.Book (String.concat name ".kind2") λdata
  (IO.bind Unit Kind.Book (IO.print.do data) λx
  (IO.done Kind.Book (Kind.Book.parse data))))

// Loads a name into a book; then, load its dependencies
Kind.load.name
: ∀(name: String)
  ∀(book: Kind.Book)
  (IO Kind.Book)
= λname λbook
  (IO.bind Unit Kind.Book (IO.print.do (String.concat "LOAD:" name)) λx
  (IO.bind Kind.Book Kind.Book (Kind.load.code name) λfile
  let defs = (String.Map.to_list Kind.Term file)
  let fold = (List.fold (Pair String Kind.Term) defs)
  let set2 = λnam λval (String.Map.set Kind.Term nam val book)
  let setP = λdef λbook (~def λx(Kind.Book) set2)
  let book = (fold Kind.Book setP book)
  let deps = (Kind.Book.get_refs file)
  (Kind.load.dependencies deps book)))
  
// Loads a list of dependencies
Kind.load.dependencies
: ∀(deps: (List String))
  ∀(book: Kind.Book)
  (IO Kind.Book)
= λdeps λbook
  let P    = λx ∀(book: Kind.Book) (IO Kind.Book)
  let cons = λdeps.head λdeps.tail λbook
    (IO.bind Kind.Book Kind.Book (Kind.load.dependency deps.head book) λbook 
    (Kind.load.dependencies deps.tail book))
  let nil = λbook (IO.done Kind.Book book)
  ((~deps P cons nil) book)

// Loads a single dependency, if not present
// FIXME: String.map.has.linear is removing the entry
Kind.load.dependency
: ∀(name: String)
  ∀(book: Kind.Book)
  (IO Kind.Book)
= λname λbook
  let has   = (String.Map.has Kind.Term name book)
  let P     = λx ∀(book: Kind.Book) (IO Kind.Book)
  let true  = λbook (IO.done Kind.Book book)
  let false = λbook (Kind.load.name name book)
  ((~has P true false) book)

//Kind.load.dependency
//: ∀(name: String)
  //∀(book: Kind.Book)
  //(IO Kind.Book)
//= λname λbook
  //let P    = λx (IO Kind.Book)
  //let new  = λhas λbook
    //let P     = λx ∀(book: Kind.Book) (IO Kind.Book)
    //let true  = λbook (IO.done Kind.Book book)
    //let false = λbook (Kind.load.name name book)
    //((~has P true false) book)
  //(~(String.Map.has.linear Kind.Term name book) P new)
