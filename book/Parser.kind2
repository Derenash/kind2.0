Parser
: ∀(A: *) *
= λA
  ∀(code: String)
  (Parser.Result A)

Parser.word
: ∀(cond: ∀(chr: Char) Bool)
  (Parser String)
= λcond λcode (Parser.word.go cond (String.skip code))

Parser.word.go
: ∀(cond: ∀(chr: Char) Bool)
  (Parser String)
= λcond λcode
  let P    = λx(Parser.Result String)
  let cons = λhead λtail 
    let P     = λx ∀(head: Char) ∀(tail: String) (Parser.Result String)
    let true  = λhead λtail
      let P    = λx (Parser.Result String)
      let done = λcode λvalue (Parser.Result.done String code (String.cons head value))
      let fail = λcode λerror (Parser.Result.fail String code error)
      (~(Parser.word.go cond tail) P done fail) 
    let false = λhead λtail
      (Parser.Result.done String tail String.nil)
    (~(cond head) P true false head tail)
  let nil =
    (Parser.Result.done String String.nil String.nil)
  (~code P cons nil)

Parser.name
: (Parser String)
= (Parser.word Char.is_name)

Parser.oper
: (Parser String)
= (Parser.word Char.is_oper)

Parser.text
: ∀(text: String)
  (Parser Unit)
= λtext λcode
  let P    = λx ∀(code: String) (Parser.Result Unit)
  let cons = λtext.head λtext.tail λcode
    let P    = λx (Parser.Result Unit)
    let cons = λcode.head λcode.tail
      let P     = λx(Parser.Result Unit)
      let true  =
        let tail = (Parser.text text.tail code.tail)
        let P    = λx(Parser.Result Unit)
        let done = λcode λvalue (Parser.Result.done Unit code value)
        let fail = λcode λerror (Parser.Result.fail Unit (String.cons code.head code) error)
        (~tail P done fail)
      let false = (Parser.Result.fail Unit code "Parse error.")
      (~(Char.equal text.head code.head) P true false)
    let nil  = (Parser.Result.done Unit code Unit.one)
    (~(String.skip code) P cons nil)
  let nil  = λcode (Parser.Result.done Unit code Unit.one)
  (~text P cons nil code)

Parser.options
: ∀(A: *)
  ∀(options: (List (Parser A)))
  (Parser A)
= λA λoptions
  let P    = λx(Parser A)
  let cons = λhead λtail λcode
    // 1. attempts to parse 'head'
    // 2. if it fails, drops the error and attempts the next parser
    let P    = λx(Parser.Result A)
    let done = λcode λvalue (Parser.Result.done A code value)
    let fail = λcode λerror ((Parser.options A tail) code)
    (~(head code) P done fail)
  let nil  = (Parser.fail A "Parse error.") // TODO: parametrize
  (~options P cons nil)

Kind.Term.parser.bind
: ∀(A: *)
  ∀(a: (Parser A))
  ∀(b: ∀(x: A) (Parser Kind.Term.Pre))
  (Parser Kind.Term.Pre)
= λA (Parser.bind A Kind.Term.Pre)

Kind.Term.parser.pure
: ∀(value: Kind.Term.Pre)
  (Parser Kind.Term.Pre)
= λA (Parser.pure Kind.Term.Pre)

Kind.Term.parser.all 
: (Parser Kind.Term.Pre)
= (Kind.Term.parser.bind Unit          (Parser.text "∀") λ_
  (Kind.Term.parser.bind String        Parser.name       λnam
  (Kind.Term.parser.bind Unit          (Parser.text ":") λ_
  (Kind.Term.parser.bind Kind.Term.Pre Kind.Term.parser       λinp
  (Kind.Term.parser.bind Unit          (Parser.text ")") λ_
  (Kind.Term.parser.bind Kind.Term.Pre Kind.Term.parser       λbod
  (Kind.Term.parser.pure λscp 
  (Kind.all nam (inp scp) λx(bod (Kind.Scope.extend nam x scp))))))))))

Kind.Term.parser.lam
: (Parser Kind.Term.Pre)
= (Kind.Term.parser.bind Unit          (Parser.text "λ") λ_
  (Kind.Term.parser.bind String        Parser.name       λnam
  (Kind.Term.parser.bind Kind.Term.Pre Kind.Term.parser       λbod
  (Kind.Term.parser.pure λscp 
  (Kind.lam nam λx(bod (Kind.Scope.extend nam x scp)))))))

// NOTE: for the APP parser, parse only `(fun arg)` forms. do not use
// loops/recursion. the extended syntax will be added later
Kind.Term.parser.app
: (Parser Kind.Term.Pre)
= (Kind.Term.parser.bind Unit          (Parser.text "(") λ_
  (Kind.Term.parser.bind Kind.Term.Pre Kind.Term.parser       λfun
  (Kind.Term.parser.bind Kind.Term.Pre Kind.Term.parser       λarg
  (Kind.Term.parser.bind Unit          (Parser.text ")") λ_
  (Kind.Term.parser.pure λscp 
  (Kind.app (fun scp) (arg scp)))))))

Kind.Term.parser.ann
: (Parser Kind.Term.Pre)
= (Kind.Term.parser.bind Unit          (Parser.text "{") λ_
  (Kind.Term.parser.bind Kind.Term.Pre Kind.Term.parser       λval
  (Kind.Term.parser.bind Unit          (Parser.text ":") λ_
  (Kind.Term.parser.bind Kind.Term.Pre Kind.Term.parser       λtyp
  (Kind.Term.parser.bind Unit          (Parser.text "}") λ_
  (Kind.Term.parser.pure λscp 
  (Kind.ann (val scp) (typ scp))))))))

// Kind.Term.parser.slf
Kind.Term.parser.slf
: (Parser Kind.Term.Pre)
= (Kind.Term.parser.bind Unit          (Parser.text "$") λ_
  (Kind.Term.parser.bind String        Parser.name       λnam
  (Kind.Term.parser.bind Kind.Term.Pre Kind.Term.parser       λbod
  (Kind.Term.parser.pure λscp 
  (Kind.slf nam λx(bod (Kind.Scope.extend nam x scp)))))))

Kind.Term.parser.ins
: (Parser Kind.Term.Pre)
= (Kind.Term.parser.bind Unit          (Parser.text "~") λ_
  (Kind.Term.parser.bind Kind.Term.Pre Kind.Term.parser       λval
  (Kind.Term.parser.pure λscp 
  (Kind.ins (val scp)))))

Kind.Term.parser.set
: (Parser Kind.Term.Pre)
= (Kind.Term.parser.bind Unit          (Parser.text "*") λ_
  (Kind.Term.parser.pure λscp 
  Kind.set))

Kind.Term.parser.def
: (Parser Kind.Term.Pre)
= (Kind.Term.parser.bind Unit          (Parser.text "let ") λ_
  (Kind.Term.parser.bind String        Parser.name          λnam
  (Kind.Term.parser.bind Unit          (Parser.text "=")    λ_
  (Kind.Term.parser.bind Kind.Term.Pre Kind.Term.parser          λval
  (Kind.Term.parser.bind Kind.Term.Pre Kind.Term.parser          λbod
  (Kind.Term.parser.pure λscp 
  (Kind.def nam (val scp) λx(bod (Kind.Scope.extend nam x scp)))))))))

Kind.Term.parser.u60
: (Parser Kind.Term.Pre)
= (Kind.Term.parser.bind Unit          (Parser.text "#U60") λ_
  (Kind.Term.parser.pure λscp 
  Kind.u60))

Kind.Term.parser.op2
: (Parser Kind.Term.Pre)
= (Kind.Term.parser.bind Unit          (Parser.text "#(") λ_
  (Kind.Term.parser.bind Kind.Oper     Parser.oper        λopr
  (Kind.Term.parser.bind Kind.Term.Pre Kind.Term.parser        λfst
  (Kind.Term.parser.bind Kind.Term.Pre Kind.Term.parser        λsnd
  (Kind.Term.parser.bind Unit          (Parser.text ")")  λ_
  (Kind.Term.parser.pure λscp 
  (Kind.op2 opr (fst scp) (snd scp))))))))

// TODO: the MAT constructor hasn't been added yet

Kind.Term.parser.num
: (Parser Kind.Term.Pre)
= (Kind.Term.parser.bind Unit     (Parser.text "#")  λ_
  (Kind.Term.parser.bind #U60     Parser.U60.decimal λnum
  (Kind.Term.parser.pure λscp 
  (Kind.num num))))

Kind.Term.parser.chr
: (Parser Kind.Term.Pre)
= ?TODO

Kind.Term.parser.str
: (Parser Kind.Term.Pre)
= ?TODO

Kind.Term.parser.hol
: (Parser Kind.Term.Pre)
= (Kind.Term.parser.bind Unit          (Parser.text "?") λ_
  (Kind.Term.parser.bind String        Parser.name       λnam
  (Kind.Term.parser.pure λscp 
  (Kind.hol nam))))

Kind.Term.parser.var
: (Parser Kind.Term.Pre)
= (Kind.Term.parser.bind String Parser.name λnam
  (Kind.Term.parser.pure λscp 
  (Kind.Scope.find nam scp)))

Parser.U60.decimal
: (Parser #U60)
= ?TODO

Parser.oper
: (Parser Kind.Oper)
= ?TODO

Kind.Term.parser
: (Parser Kind.Term.Pre)
= let TRY = (List.cons (Parser Kind.Term.Pre))
  let END = (List.nil (Parser Kind.Term.Pre))
  (Parser.options Kind.Term.Pre
  (TRY Kind.Term.parser.all
  (TRY Kind.Term.parser.lam
  (TRY Kind.Term.parser.app
  (TRY Kind.Term.parser.ann
  (TRY Kind.Term.parser.slf
  (TRY Kind.Term.parser.ins
  (TRY Kind.Term.parser.set
  (TRY Kind.Term.parser.def
  (TRY Kind.Term.parser.u60
  (TRY Kind.Term.parser.op2
  (TRY Kind.Term.parser.num
  (TRY Kind.Term.parser.hol
  (TRY Kind.Term.parser.var
  END))))))))))))))
