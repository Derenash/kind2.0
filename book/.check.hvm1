// Types
// -----

//data Maybe
  //= (Some value)
  //| None

//data Bool
  //= False
  //| True

//data Pair
  //= (Pair fst snd)

//data Term
  //= (All nam inp bod)
  //| (Lam nam bod)
  //| (App fun arg)
  //| (Ann val typ)
  //| (Slf nam typ bod)
  //| (Ins val)
  //| (Ref nam sub val)
  //| (Let nam val bod)
  //| (Set)
  //| (U60)
  //| (Num val)
  //| (Op2 opr fst snd)
  //| (Mat nam x z s p)
  //| (Txt txt)
  //| (Hol nam ctx)
  //| (Var nam idx) 
  //| (Src src val)

// Prelude
// -------

(U60.seq 0 cont) = (cont 0)
(U60.seq n cont) = (cont n)

(String.seq (String.cons x xs) cont) = (U60.seq x λx(String.seq xs λxs(cont (String.cons x xs))))
(String.seq String.nil         cont) = (cont String.nil)

(Print dep []  value) = value
(Print dep msg value) = (String.seq (String.join msg) λstr(HVM.log str value))
//(Print dep []  value) = value
//(Print dep msg value) = (If (> dep 10) 1 (HVM.print (String.join msg) value))

(NewLine) = (String.cons 10 String.nil)
(Quote)   = (String.cons 34 String.nil)

(And True  b) = b
(And False b) = False

(Or True  b) = True
(Or False b) = b

(If 0 t f) = f
(If n t f) = t

(When None       some none) = none
(When (Some val) some none) = (some val)

(U60.show n)                = (U60.show.go n String.nil)
(U60.show.go n res)         = (U60.show.go.match (< n 10) n res)
(U60.show.go.match 0 n res) = (U60.show.go (/ n 10) (String.cons (+ '0' (% n 10)) res))
(U60.show.go.match i n res) = (String.cons (+ '0' n) res)

(U60.name n)    = (U60.name.go (+ n 1))
(U60.name.go 0) = ""
(U60.name.go n) = (String.cons (+ 97 (% (- n 1) 26)) (U60.name.go (/ (- n 1) 26)))

(Same String.nil         String.nil)         = 1
(Same String.nil         (String.cons y ys)) = 0
(Same (String.cons x xs) String.nil)         = 0
(Same (String.cons x xs) (String.cons y ys)) = (& (== x y) (Same xs ys))

(Find name List.nil)                        = None
(Find name (List.cons (Pair nam val) tail)) = (If (Same nam name) (Some val) (Find name tail))

(List.map f (List.cons x xs)) = (List.cons (f x) (List.map f xs))
(List.map f List.nil)         = List.nil

(String.concat String.nil         ys) = ys
(String.concat (String.cons x xs) ys) = (String.cons x (String.concat xs ys))

(String.join List.nil)         = ""
(String.join (List.cons x xs)) = (String.concat x (String.join xs))

(String.tail String.nil)         = String.nil
(String.tail (String.cons x xs)) = xs

(Pair.fst (Pair fst snd)) = fst
(Pair.snd (Pair fst snd)) = snd

(Pair.get (Pair fst snd) fun) = (fun fst snd)

(Maybe.match (Some value) some none) = (some value)
(Maybe.match None         some none) = none

(Maybe.pure x) = (Some x)
(Maybe.bind a b) = (Maybe.match a λvalue(b value) None)

// Converts an U60 to a bitstring
(U60.to_bits 0) = E
(U60.to_bits 1) = (I E)
(U60.to_bits n) = (If (== (% n 2) 0) (O (U60.to_bits (/ n 2))) (I (U60.to_bits (/ n 2))))

(String.color RESET)      = (String.cons 27 "[0m")
(String.color BRIGHT)     = (String.cons 27 "[1m")
(String.color DIM)        = (String.cons 27 "[2m")
(String.color UNDERSCORE) = (String.cons 27 "[4m")
(String.color BLINK)      = (String.cons 27 "[5m")
(String.color REVERSE)    = (String.cons 27 "[7m")
(String.color HIDDEN)     = (String.cons 27 "[8m")
(String.color BLACK)      = (String.cons 27 "[30m")
(String.color RED)        = (String.cons 27 "[31m")
(String.color GREEN)      = (String.cons 27 "[32m")
(String.color YELLOW)     = (String.cons 27 "[33m")
(String.color BLUE)       = (String.cons 27 "[34m")
(String.color MAGENTA)    = (String.cons 27 "[35m")
(String.color CYAN)       = (String.cons 27 "[36m")
(String.color WHITE)      = (String.cons 27 "[37m")
(String.color GRAY)       = (String.cons 27 "[90m")
(String.color BG_BLACK)   = (String.cons 27 "[40m")
(String.color BG_RED)     = (String.cons 27 "[41m")
(String.color BG_GREEN)   = (String.cons 27 "[42m")
(String.color BG_YELLOW)  = (String.cons 27 "[43m")
(String.color BG_BLUE)    = (String.cons 27 "[44m")
(String.color BG_MAGENTA) = (String.cons 27 "[45m")
(String.color BG_CYAN)    = (String.cons 27 "[46m")
(String.color BG_WHITE)   = (String.cons 27 "[47m")
(String.color BG_GRAY)    = (String.cons 27 "[100m")
(String.color x)          = "?"

// BitsMap
// -------

(Map.new) = List.nil

(Map.has eq k (List.cons (Pair key val) map)) = (If (eq key k) 1 (Map.has eq k map))
(Map.has eq k List.nil)                       = 0

(Map.ins eq k v (List.cons (Pair key val) map)) = ((If (eq key k) λmap(None) λmap(Maybe.bind (Map.ins eq k v map) λmap(Some (List.cons (Pair key val) map)))) map)
(Map.ins eq k v List.nil)                       = (Some (List.cons (Pair k v) List.nil))

(Map.set eq k v (List.cons (Pair key val) map)) = ((If (eq key k) λmap(List.cons (Pair k v) map) λmap(List.cons (Pair key val) (Map.set eq k v map))) map)
(Map.set eq k v List.nil)                       = (List.cons (Pair k v) List.nil)

(Map.get eq k (List.cons (Pair key val) map)) = (If (eq key k) (Some val) (Map.get eq k map))
(Map.get eq k List.nil)                       = None

// Holes
// -----

(Subst (List.cons (Pair nam None)     subs) val) = (Subst subs (val None))
(Subst (List.cons (Pair nam (Some x)) subs) val) = (Subst subs (val (Some x)))
(Subst List.nil                             val) = val

// Evaluation
// ----------

// Evaluation levels:
// - 0: reduces refs never
// - 1: reduces refs on redexes
// - 2: reduces refs always

(Reduce lv (App fun arg))     = (Reduce.app lv (Reduce lv fun) arg)
(Reduce lv (Ann val typ))     = (Reduce lv val)
(Reduce lv (Ins val))         = (Reduce lv val)
(Reduce lv (Ref nam sub val)) = (Reduce.ref lv nam sub (Reduce lv val))
(Reduce lv (Let nam val bod)) = (Reduce lv (bod val))
(Reduce lv (Op2 opr fst snd)) = (Reduce.op2 lv opr (Reduce lv fst) (Reduce lv snd))
(Reduce lv (Mat nam x z s p)) = (Reduce.mat lv nam (Reduce lv x) z s p)
(Reduce lv (Met nam val))     = (Reduce.met lv nam val)
(Reduce lv (Txt txt))         = (Reduce.txt lv txt)
(Reduce lv (Src src val))     = (Reduce lv val)
(Reduce lv val)               = val

(Reduce.app 2  (Ref _ _ val) arg) = (Reduce.app 2 val arg) // FIXME: should this be here? (no.)
(Reduce.app 1  (Ref _ _ val) arg) = (Reduce.app 1 val arg) // FIXME: should this be here? (no.)
(Reduce.app lv (Lam nam bod) arg) = (Reduce lv (bod (Reduce 0 arg)))
(Reduce.app lv fun           arg) = (App fun arg)

(Reduce.op2 1  op  (Ref _ _ x) (Num snd))   = (Reduce.op2 1 op x snd)
(Reduce.op2 2  op  (Ref _ _ x) (Num snd))   = (Reduce.op2 2 op x snd)
(Reduce.op2 1  op  (Num fst)   (Ref _ _ x)) = (Reduce.op2 1 op fst x)
(Reduce.op2 2  op  (Num fst)   (Ref _ _ x)) = (Reduce.op2 2 op fst x)
(Reduce.op2 lv ADD (Num fst)   (Num snd))   = (Num (+ fst snd))
(Reduce.op2 lv SUB (Num fst)   (Num snd))   = (Num (- fst snd))
(Reduce.op2 lv MUL (Num fst)   (Num snd))   = (Num (* fst snd))
(Reduce.op2 lv DIV (Num fst)   (Num snd))   = (Num (/ fst snd))
(Reduce.op2 lv MOD (Num fst)   (Num snd))   = (Num (% fst snd))
(Reduce.op2 lv EQ  (Num fst)   (Num snd))   = (Num (== fst snd))
(Reduce.op2 lv NE  (Num fst)   (Num snd))   = (Num (!= fst snd))
(Reduce.op2 lv LT  (Num fst)   (Num snd))   = (Num (< fst snd))
(Reduce.op2 lv GT  (Num fst)   (Num snd))   = (Num (> fst snd))
(Reduce.op2 lv LTE (Num fst)   (Num snd))   = (Num (<= fst snd))
(Reduce.op2 lv GTE (Num fst)   (Num snd))   = (Num (>= fst snd))
(Reduce.op2 lv AND (Num fst)   (Num snd))   = (Num (& fst snd))
(Reduce.op2 lv OR  (Num fst)   (Num snd))   = (Num (| fst snd))
(Reduce.op2 lv XOR (Num fst)   (Num snd))   = (Num (^ fst snd))
(Reduce.op2 lv LSH (Num fst)   (Num snd))   = (Num (<< fst snd))
(Reduce.op2 lv RSH (Num fst)   (Num snd))   = (Num (>> fst snd))
(Reduce.op2 lv opr fst         snd)         = (Op2 opr fst snd)

(Reduce.mat 2  nam (Ref _ _ x)         z s p) = (Reduce.mat 2 nam x z s p)
(Reduce.mat 1  nam (Ref _ _ x)         z s p) = (Reduce.mat 1 nam x z s p)
(Reduce.mat lv nam (Num 0)             z s p) = (Reduce lv z)
(Reduce.mat lv nam (Num n)             z s p) = (Reduce lv (s (Num (- n 1))))
(Reduce.mat lv nam (Op2 ADD (Num 1) k) z s p) = (Reduce lv (s k))
(Reduce.mat lv nam val                 z s p) = (Mat nam val z s p)

(Reduce.ref 2  nam sub val) = (Reduce 2 (Subst sub val))
(Reduce.ref 1  nam sub val) = (Ref nam sub val)
(Reduce.ref lv nam sub val) = (Ref nam sub val)

(Reduce.met lv nam None)     = (Met nam None)
(Reduce.met lv nam (Some x)) = (Reduce lv x)

(Reduce.txt lv (String.cons x xs)) = (Reduce lv (App (App Book.String.cons (Num x)) (Txt xs)))
(Reduce.txt lv String.nil)         = (Reduce lv Book.String.nil)
(Reduce.txt lv val)                = (Txt val)

(Normal lv term dep) = (Normal.go lv (Normal.prefer (Reduce 0 term) (Reduce lv term)) dep)

(Normal.prefer soft (Lam _ _))   = soft
(Normal.prefer soft (Slf _ _ _)) = soft
(Normal.prefer soft (All _ _ _)) = soft
(Normal.prefer soft hard)        = hard

(Normal.go lv (All nam inp bod) dep) = (All nam (Normal lv inp dep) λx(Normal lv (bod (Var nam dep)) (+ dep 1)))
(Normal.go lv (Lam nam bod)     dep) = (Lam nam λx(Normal lv (bod (Var nam dep)) (+ 1 dep)))
(Normal.go lv (App fun arg)     dep) = (App (Normal lv fun dep) (Normal lv arg dep))
(Normal.go lv (Ann val typ)     dep) = (Ann (Normal lv val dep) (Normal lv typ dep))
(Normal.go lv (Slf nam typ bod) dep) = (Slf nam typ λx(Normal lv (bod (Var nam dep)) (+ 1 dep)))
(Normal.go lv (Ins val)         dep) = (Ins (Normal lv val dep))
(Normal.go lv (Ref nam sub val) dep) = (Ref nam sub (Normal lv val dep))
(Normal.go lv (Let nam val bod) dep) = (Let nam (Normal lv val dep) λx(Normal lv (bod (Var nam dep)) (+ 1 dep)))
(Normal.go lv (Hol nam ctx)     dep) = (Hol nam ctx)
(Normal.go lv (Met nam val)     dep) = (Met nam (Maybe.match val λx(Some (Normal lv x dep)) None))
(Normal.go lv Set               dep) = Set
(Normal.go lv U60               dep) = U60
(Normal.go lv (Num val)         dep) = (Num val)
(Normal.go lv (Op2 opr fst snd) dep) = (Op2 opr (Normal lv fst dep) (Normal lv snd dep))
(Normal.go lv (Mat nam x z s p) dep) = (Mat nam (Normal lv x dep) (Normal lv z dep) λk(Normal lv (s (Var (String.concat nam "-1") dep)) dep) λk(Normal lv (p (Var nam dep)) dep))
(Normal.go lv (Txt val)         dep) = (Txt val)
(Normal.go lv (Var nam idx)     dep) = (Var nam idx)
(Normal.go lv (Src src val)     dep) = (Src src (Normal lv val dep))

// Checker
// -------

// type Result A = (Done Logs A) | (Fail Logs String)
// type Checker A = Logs -> (Result A)

(Result.match (Done logs value) done fail) = (done logs value)
(Result.match (Fail logs error) done fail) = (fail logs error)     

//(State.get fill got) = (got fill logs)
//(State.new)          = []

(Checker.bind a b)  = λlogs (Result.match (a logs) λlogsλvalue((b value) logs) λlogsλerror(Fail logs error))
(Checker.pure a)    = λlogs (Done logs a)
(Checker.fail e)    = λlogs (Fail logs e)
(Checker.run chk)   = (chk [])
(Checker.log msg)   = λlogs (Done (List.cons msg logs) 1)
(Checker.save)      = λlogs (Done logs logs)
(Checker.load logs) = λeras (Done logs 0)

// Equality
// --------

// The conversion checkers works as follows:
// - 1. If the two sides are structurally identical, they're equal.
// - 2. Otherwise, reduce both sides.
// - 3. If the two sides are structurally identical, they're equal.
// - 4. Otherwise, recurse on both sides and check if all fields are equal.
// This algorithm will return true when both sides reduce to the same normal
// form, but it will halt early if both sides become identical at any point
// during the reduction, allowing checking recursive terms. This is enough to
// cover any interesting term. Note we need to be careful with self-types, which
// must be "un-unrolled" to avoid loops. Read `docs/equality.md` for more info.

// Checks if two term are equal
(Equal a b dep) = 
  //(Print dep ["Equal: " NewLine "- " (Show a dep) NewLine "- " (Show b dep)]
  (Compare a b dep
  let a = (Reduce 2 a)
  let b = (Reduce 2 b)
  (Compare a b dep
  (Similar a b dep)))

// Checks if two terms are structurally identical
// If yes, returns 1 (identical) or 2 (suspended)
// If not, undoes effects (logs, unifications, etc.)
(Compare a b dep else) =
  (Checker.bind (Checker.save) λlogs
  (Checker.bind (Identical a b dep) λequal
  (If equal
    (Checker.pure equal)
    (Checker.bind (Checker.load logs) λx (else)))))

// Checks if all components of a term are equal
(Similar (All a.nam a.inp a.bod) (All b.nam b.inp b.bod) dep) =
  (Checker.bind (Equal a.inp b.inp dep) λe.inp
  (Checker.bind (Equal (a.bod (Var a.nam dep)) (b.bod (Var b.nam dep)) (+ 1 dep)) λe.bod
  (Checker.pure (& e.inp e.bod))))
(Similar (Lam a.nam a.bod) (Lam b.nam b.bod) dep) =
  (Equal (a.bod (Var a.nam dep)) (b.bod (Var b.nam dep)) (+ 1 dep))
(Similar (App a.fun a.arg) (App b.fun b.arg) dep) =
  (Checker.bind (Equal a.fun b.fun dep) λe.fun
  (Checker.bind (Equal a.arg b.arg dep) λe.arg
  (Checker.pure (& e.fun e.arg))))
(Similar (Slf a.nam a.typ a.bod) (Slf b.nam b.typ b.bod) dep) =
  (Similar (Reduce 0 a.typ) (Reduce 0 b.typ) dep) // <- must call Similar, NOT Equal
(Similar (Hol a.nam a.ctx) (Hol b.nam b.ctx) dep) =
  (Checker.pure (Same a.nam b.nam))
(Similar (Met a.nam a.val) (Met b.nam b.val) dep) =
  (Checker.pure (Same a.nam b.nam))
(Similar (Op2 a.opr a.fst a.snd) (Op2 b.opr b.fst b.snd) dep) =
  (Checker.bind (Equal a.fst b.fst dep) λe.fst
  (Checker.bind (Equal a.snd b.snd dep) λe.snd
  (Checker.pure (Same e.fst e.snd))))
(Similar (Mat a.nam a.x a.z a.s a.p) (Mat b.nam b.x b.z b.s b.p) dep) =
  (Checker.bind (Equal a.x b.x dep) λe.x
  (Checker.bind (Equal a.z b.z dep) λe.z
  (Checker.bind (Equal (a.s (Var (String.concat a.nam "-1") dep)) (b.s (Var (String.concat b.nam "-1") dep)) dep) λe.s
  (Checker.bind (Equal (a.p (Var a.nam dep)) (b.p (Var b.nam dep)) dep) λe.p
  (& e.x (& e.z (& e.s e.p)))))))
(Similar a b dep) =
  (Checker.pure 0)

// Checks if two terms are structurally identical
(Identical a b dep) =
  //(Print dep ["Identical?" NewLine "- " (Show a dep) NewLine "- " (Show b dep)]
  (Unify.try b a dep
  (Unify.try a b dep
  (Identical.go a b dep)))

(Identical.go (All a.nam a.inp a.bod) (All b.nam b.inp b.bod) dep) =
  (Checker.bind (Identical a.inp b.inp dep) λi.inp
  (Checker.bind (Identical (a.bod (Var a.nam dep)) (b.bod (Var b.nam dep)) (+ 1 dep)) λi.bod
  (Checker.pure (& i.inp i.bod))))
(Identical.go (Lam a.nam a.bod) (Lam b.nam b.bod) dep) =
  (Identical (a.bod (Var a.nam dep)) (b.bod (Var b.nam dep)) (+ 1 dep))
(Identical.go (App a.fun a.arg) (App b.fun b.arg) dep) =
  (Checker.bind (Identical a.fun b.fun dep) λi.fun
  (Checker.bind (Identical a.arg b.arg dep) λi.arg
  (Checker.pure (& i.fun i.arg))))
(Identical.go (Slf a.nam a.typ a.bod) (Slf b.nam b.typ b.bod) dep) =
  (Identical a.typ b.typ dep)
(Identical.go (Ins a.val) b dep) =
  (Identical a.val b dep)
(Identical.go a (Ins b.val) dep) =
  (Identical a b.val dep)
(Identical.go (Let a.nam a.val a.bod) b dep) =
  (Identical (a.bod a.val) b dep)
(Identical.go a (Let b.nam b.val b.bod) dep) =
  (Identical a (b.bod b.val) dep)
(Identical.go Set Set dep) =
  (Checker.pure 1)
(Identical.go (Ann a.val a.typ) b dep) =
  (Identical a.val b dep)
(Identical.go a (Ann b.val b.typ) dep) =
  (Identical a b.val dep)
(Identical.go (Met a.nam (Some a.val)) b dep) =
  (Identical a.val b dep)
(Identical.go a (Met b.nam (Some b.val)) dep) =
  (Identical a b.val dep)
(Identical.go (Met a.nam None) (Met b.nam None) dep) =
  (Checker.pure (Same a.nam b.nam))
(Identical.go (Hol a.nam a.ctx) (Hol b.nam b.ctx) dep) =
  (Checker.pure (Same a.nam b.nam))
(Identical.go U60 U60 dep) =
  (Checker.pure 1)
(Identical.go (Num a.val) (Num b.val) dep) =
  (Checker.pure (== a.val b.val))
(Identical.go (Op2 a.opr a.fst a.snd) (Op2 b.opr b.fst b.snd) dep) =
  (Checker.bind (Identical a.fst b.fst dep) λi.fst
  (Checker.bind (Identical a.snd b.snd dep) λi.snd
  (Checker.pure (& i.fst i.snd))))
(Identical.go (Mat a.nam a.x a.z a.s a.p) (Mat b.nam b.x b.z b.s b.p) dep) =
  (Checker.bind (Identical a.x b.x dep) λi.x
  (Checker.bind (Identical a.z b.z dep) λi.z
  (Checker.bind (Identical (a.s (Var (String.concat a.nam "-1") dep)) (b.s (Var (String.concat b.nam "-1") dep)) dep) λi.s
  (Checker.bind (Identical (a.p (Var a.nam dep)) (b.p (Var b.nam dep)) dep) λi.p
  (& i.x (& i.z (& i.s i.p)))))))
(Identical.go (Txt a.txt) (Txt b.txt) dep) =
  (Checker.pure (Same a.txt b.txt))
(Identical.go (Src a.src a.val) b dep) =
  (Identical a.val b dep)
(Identical.go a (Src b.src b.val) dep) =
  (Identical a b.val dep)
(Identical.go (Ref a.nam a.sub a.val) (Ref b.nam b.sub b.val) dep) =
  (Checker.pure (Same a.nam b.nam))
(Identical.go (Var a.nam a.idx) (Var b.nam b.idx) dep) =
  (Checker.pure (== a.idx b.idx))
(Identical.go a b dep) =
  (Checker.pure 0)

// Unification
// -----------

// The unification algorithm is a simple pattern unifier, based on smalltt:
// > https://github.com/AndrasKovacs/elaboration-zoo/blob/master/03-holes/Main.hs
// The 'Unify.try' fn will attempt to match the following pattern:
//   (?A x y z ...) = B
// Where:
//   1. The LHS spine, `x y z ...`, consists of distinct variables.
//   2. Every free var of the RHS, `B`, occurs in the spine.
//   3. The LHS hole, `?A`, doesn't occur in the RHS, `B`.
// If it is successful, it outputs the following substitution:
//   ?A = λx λy λz ... B
// In this checker, we don't allow holes to occur in solutions at all.

// Unify.try : Term -> Term -> U60 -> (Checker U60) -> (Checker U60)
(Unify.try a b dep else) =
  // Attempts to unify the pattern
  (Maybe.match (Unify.solve a b dep Map.new)
    // If successful, logs the solution
    λkv(Pair.get kv λkλv
      (Checker.bind (Checker.log (Solve k v dep)) λx
      (Checker.pure 1)))
    // Otherwise, signals to skip equality if this is a pattern
    (If (Unify.skip a)
      (Checker.pure 1)
      (else)))

// If LHS is a solveable pattern, generates its solution.
// Unify.solve : Term -> Term -> U60 -> (Map U60 Term) -> (Maybe (Pair nam Term))
(Unify.solve (App fun (Var nam idx)) b dep ctx) =
  (Maybe.bind (Map.ins λaλb(== a b) idx $x ctx) λctx
  (Maybe.bind (Unify.solve fun b dep ctx) λkv 
  (Pair.get kv λkλv(Maybe.pure (Pair k (Lam nam λ$x(v)))))))
(Unify.solve (Met nam None) b dep ctx) =
  (Maybe.bind (Unify.solution b dep nam ctx) λneo
  (Maybe.pure (Pair nam neo)))
(Unify.solve (App fun (Ann val _))        b dep ctx) = (Unify.solve (App fun val) b dep ctx)
(Unify.solve (App fun (Ins val))          b dep ctx) = (Unify.solve (App fun val) b dep ctx)
(Unify.solve (App fun (Src _ val))        b dep ctx) = (Unify.solve (App fun val) b dep ctx)
(Unify.solve (App fun (Met _ (Some val))) b dep ctx) = (Unify.solve (App fun val) b dep ctx)
(Unify.solve (Ann val typ)                b dep ctx) = (Unify.solve val b dep ctx)
(Unify.solve (Ins val)                    b dep ctx) = (Unify.solve val b dep ctx)
(Unify.solve (Src src val)                b dep ctx) = (Unify.solve val b dep ctx)
(Unify.solve (Met nam (Some val))         b dep ctx) = (Unify.solve val b dep ctx)
(Unify.solve other                        b dep ctx) = None

// If LHS is an unsolveable pattern, skips its type-checking.
// Unify.skip : Term -> Bool
(Unify.skip (App fun arg))  = (Unify.skip fun)
(Unify.skip (Ann val typ))  = (Unify.skip val)
(Unify.skip (Ins val))      = (Unify.skip val)
(Unify.skip (Src src val))  = (Unify.skip val)
(Unify.skip (Met nam None)) = 1
(Unify.skip (Hol nam ctx))  = 1
(Unify.skip other)          = 0

// Attempts to convert RHS to a solution, checking the criteria.
// Unify.solution : Term -> U60 -> String -> (Map U60 Term) -> (Maybe Term)
(Unify.solution (All nam inp bod) dep hol ctx) =
  (Maybe.bind (Unify.solution inp dep hol ctx) λinp
  (Maybe.bind (Unify.solution (bod (Var nam dep)) (+ dep 1) hol ctx) λbod
  (Maybe.pure (All nam inp λ_(bod)))))
(Unify.solution (Lam nam bod) dep hol ctx) =
  (Maybe.bind (Unify.solution (bod (Var nam dep)) (+ 1 dep) hol ctx) λbod
  (Maybe.pure (Lam nam λ_(bod))))
(Unify.solution (App fun arg) dep hol ctx) =
  (Maybe.bind (Unify.solution fun dep hol ctx) λfun
  (Maybe.bind (Unify.solution arg dep hol ctx) λarg
  (Maybe.pure (App fun arg))))
(Unify.solution (Ann val typ) dep hol ctx) =
  (Maybe.bind (Unify.solution val dep hol ctx) λval
  (Maybe.bind (Unify.solution typ dep hol ctx) λtyp
  (Maybe.pure (Ann val typ))))
(Unify.solution (Slf nam typ bod) dep hol ctx) =
  (Unify.solution typ dep hol ctx)
(Unify.solution (Ins val) dep hol ctx) =
  (Maybe.bind (Unify.solution val dep hol ctx) λval
  (Maybe.pure (Ins val)))
(Unify.solution (Ref nam sub val) dep hol ctx) =
  (Maybe.pure (Ref nam sub val))
(Unify.solution (Let nam val bod) dep hol ctx) =
  (Maybe.bind (Unify.solution val dep hol ctx) λval
  (Maybe.bind (Unify.solution (bod (Var nam dep)) (+ 1 dep) hol ctx) λbod
  (Maybe.pure (Let nam val λ_(bod)))))
(Unify.solution (Met nam None) dep hol ctx) =
  None // holes can't appear in the solution
  //(If (Same nam hol) None (Maybe.pure (Met nam None)))
(Unify.solution (Met nam (Some val)) dep hol ctx) =
  (Maybe.bind (Unify.solution val dep hol ctx) λval
  (Maybe.pure (Met nam (Some val))))
(Unify.solution (Hol nam _) dep hol ctx) =
  (Maybe.pure (Hol nam [])) // FIXME?
(Unify.solution Set dep hol ctx) =
  (Maybe.pure Set)
(Unify.solution U60 dep hol ctx) =
  (Maybe.pure U60)
(Unify.solution (Num val) dep hol ctx) =
  (Maybe.pure (Num val))
(Unify.solution (Op2 opr fst snd) dep hol ctx) =
  (Maybe.bind (Unify.solution fst dep hol ctx) λfst
  (Maybe.bind (Unify.solution snd dep hol ctx) λsnd
  (Maybe.pure (Op2 opr fst snd))))
(Unify.solution (Mat nam x z s p) dep hol ctx) =
  (Maybe.bind (Unify.solution x dep hol ctx) λx
  (Maybe.bind (Unify.solution z dep hol ctx) λz
  (Maybe.bind (Unify.solution (s (Var (String.concat nam "-1") dep)) dep hol ctx) λs
  (Maybe.bind (Unify.solution (p (Var nam dep)) dep hol ctx) λp
  (Maybe.pure (Mat nam x z λ_(s) λ_(p)))))))
(Unify.solution (Txt val) dep hol ctx) =
  (Maybe.pure (Txt val))
(Unify.solution (Var nam idx) dep hol ctx) =
  (Maybe.bind (Map.get λaλb(== a b) idx ctx) λval
  (Maybe.pure val))
(Unify.solution (Src src val) dep hol ctx) =
  (Maybe.bind (Unify.solution val dep hol ctx) λval
  (Maybe.pure (Src src val)))
(Unify.solution term dep hol ctx) =
  (HVM.log (UNREACHALBE (Show term dep)) None)

// Type-Checking
// -------------

(IfAll (All nam inp bod) yep nop) = (yep nam inp bod)
(IfAll other             yep nop) = nop

(IfSlf (Slf nam typ bod) yep nop) = (yep nam typ bod)
(IfSlf other             yep nop) = nop

//(Infer term dep) = (Print dep ["Infer: " (Show term dep)] (Infer.match term dep))
(Infer term dep) = (Infer.match term dep)

(Infer.match (All nam inp bod) dep) =
  (Checker.bind (Check 0 inp Set dep) λinp_typ
  (Checker.bind (Check 0 (bod (Ann (Var nam dep) inp)) Set (+ 1 dep)) λbod_typ
  (Checker.pure Set)))
(Infer.match (App fun arg) dep) =
  (Checker.bind (Infer fun dep) λfun_typ
  ((IfAll (Reduce 2 fun_typ)
    λfun_nam λfun_typ.inp λfun_typ.bod λfun λarg
      (Checker.bind (Check 0 arg fun_typ.inp dep) λvty
      (Checker.pure (fun_typ.bod arg)))
    λfun λarg
      (Checker.fail (Error 0 fun_typ (Hol "function" []) (App fun arg) dep)))
    fun arg))
(Infer.match (Ann val typ) dep) =
  (Checker.pure typ)
(Infer.match (Slf nam typ bod) dep) =
  (Checker.bind (Check 0 (bod (Ann (Var nam dep) typ)) Set (+ dep 1)) λslf
  (Checker.pure Set))
(Infer.match (Ins val) dep) =
  (Checker.bind (Infer val dep) λvty
  ((IfSlf (Reduce 2 vty)
    λvty.nam λvty.typ λvty.bod λval
      (Checker.pure (vty.bod (Ins val)))
    λval
      (Checker.fail (NonSlfIns (Ins val))))
    val))
(Infer.match (Ref nam sub val) dep) = 
  (Infer val dep)
(Infer.match Set dep) =
  (Checker.pure Set)
(Infer.match U60 dep) =
  (Checker.pure Set)
(Infer.match (Num num) dep) =
  (Checker.pure U60)
(Infer.match (Txt txt) dep) =
  (Checker.pure Book.String)
(Infer.match (Op2 opr fst snd) dep) =
  (Checker.bind (Check 0 fst U60 dep) λfst
  (Checker.bind (Check 0 snd U60 dep) λsnd
  (Checker.pure U60)))
(Infer.match (Mat nam x z s p) dep) =
  (Checker.bind (Check 0 x U60 dep) λx_typ
  (Checker.bind (Check 0 (p (Ann (Var nam dep) U60)) Set dep) λp_typ
  (Checker.bind (Check 0 z (p (Num 0)) dep) λz_typ
  (Checker.bind (Check 0 (s (Ann (Var (String.concat nam "-1") dep) U60)) (p (Op2 ADD (Num 1) (Var (String.concat nam "-1") dep))) (+ dep 1)) λs_typ
  (Checker.pure (p x))))))
(Infer.match (Lam nam bod) dep) =
  (Checker.fail (Error 0 (Hol "untyped_term" []) (Hol "type_annotation" []) (Lam nam bod) dep))
(Infer.match (Let nam val bod) dep) =
  (Checker.fail (Error 0 (Hol "untyped_term" []) (Hol "type_annotation" []) (Let nam val bod) dep))
(Infer.match (Hol nam ctx) dep) =
  (Checker.fail (Error 0 (Hol "untyped_term" []) (Hol "type_annotation" []) (Hol nam ctx) dep))
(Infer.match (Met nam (Some val)) dep) =
  (Infer.match val dep)
(Infer.match (Met nam None) dep) =
  (Checker.fail (Error 0 (Hol "untyped_term" []) (Hol "type_annotation" []) (Met nam None) dep))
(Infer.match (Var nam idx) dep) =
  (Checker.fail (Error 0 (Hol "untyped_term" []) (Hol "type_annotation" []) (Var nam idx) dep))
(Infer.match (Src src val) dep) =
  (Infer.match val dep)

//(Check src term type dep) = (Print dep ["Check: " (Show term dep) " :: " (Show type dep) " ~> " (Show (Reduce 1 type) dep)] (Check.match src term type dep))
(Check src term type dep) = (Check.match src term type dep)

(Check.match src (Lam term.nam term.bod) type dep) =
  ((IfAll (Reduce 2 type)
    λtype.nam λtype.inp λtype.bod λterm.bod
      let ann  = (Ann (Var term.nam dep) type.inp)
      let term = (term.bod ann)
      let type = (type.bod ann)
      (Check 0 term type (+ dep 1))
    λterm.bod
      (Infer (Lam term.nam term.bod) dep))
    term.bod)
(Check.match src (Ins term.val) type dep) =
  ((IfSlf (Reduce 2 type)
    λtype.nam λtype.typ λtype.bod λterm.val
      (Check 0 term.val (type.bod (Ins term.val)) dep)
    λterm.val
      (Infer (Ins term.val) dep))
    term.val)
(Check.match src (Let term.nam term.val term.bod) type dep) =
  (Check 0 (term.bod term.val) type (+ 1 dep))
(Check.match src (Hol term.nam term.ctx) type dep) =
  (Checker.bind (Checker.log (Found term.nam type term.ctx dep)) λx
  (Checker.pure 0))
(Check.match src (Met term.nam (Some term.val)) type dep) =
  (Check src term.val type dep)
(Check.match src (Met term.nam None) type dep) =
  (Checker.pure 0)
(Check.match src (Ref term.nam term.sub (Ann term.val term.typ)) type dep) = // better printing
  (Checker.bind (Equal type term.typ dep) λequal
  (Check.report src equal term.typ type (Ref term.nam term.sub term.val) dep))
(Check.match src (Src term.src term.val) type dep) =
  (Check term.src term.val type dep)
//(Check.match src (Ref term.nam term.val) type dep) =
  //(Check term.val type dep)
(Check.match src term type dep) =
  (Check.verify src term type dep)

(Check.verify src term type dep) =
  (Checker.bind (Infer term dep) λinfer
  (Checker.bind (Equal type infer dep) λequal
  (Check.report src equal infer type term dep)))

(Check.report src 0 detected expected value dep) =
  (Checker.fail (Error src detected expected value dep))
(Check.report src n detected expected value dep) =
  (Checker.pure 0)

// Syntax
// ------

(Show (All nam inp bod) dep) =
  let nam = nam
  let inp = (Show inp dep)
  let bod = (Show (bod (Var nam dep)) (+ dep 1))
  (String.join ["∀(" nam ": " inp ") " bod])
(Show (Lam nam bod) dep) =
  let nam = nam
  let bod = (Show (bod (Var nam dep)) (+ dep 1))
  (String.join ["λ" nam " " bod])
(Show (App fun arg) dep) =
  let fun = (Show.unwrap (Show fun dep))
  let arg = (Show arg dep)
  (String.join ["(" fun " " arg ")"])
(Show (Ann val typ) dep) =
  let val = (Show val dep)
  let typ = (Show typ dep)
  (String.join ["{" val ": " typ "}"])
(Show (Slf nam typ bod) dep) =
  let nam = nam
  let typ = (Show typ dep)
  let bod = (Show (bod (Var nam dep)) (+ dep 1))
  (String.join ["$(" nam ": " typ ") " bod])
(Show (Ins val) dep) =
  let val = (Show val dep)
  (String.join ["~" val])
(Show (Ref nam sub val) dep) =
  nam
(Show (Let nam val bod) dep) =
  let nam = nam
  let val = (Show val dep)
  let bod = (Show (bod (Var nam dep)) (+ dep 1))
  (String.join ["let " nam " = " val "; " bod])
(Show Set dep) =
  "*"
(Show U60 dep) =
  "#U60"
(Show (Num val) dep) =
  let val = (U60.show val)
  (String.join ["#" val])
(Show (Op2 opr fst snd) dep) =
  let opr = (Op2.show opr)
  let fst = (Show fst dep)
  let snd = (Show snd dep)
  (String.join ["#(" opr " " fst " " snd ")"])
(Show (Mat nam x z s p) dep) =
  let nam = nam
  let x   = (Show x dep)
  let z   = (Show z dep)
  let s   = (Show (s (Var (String.concat nam "-1") dep)) (+ dep 1))
  let p   = (Show (p (Var nam dep)) dep)
  (String.join ["#match " nam " = " x " { #0: " z " #+: " s " }: " p])
(Show (Txt txt) dep) =
  (String.join [Quote txt Quote])
(Show (Hol nam ctx) dep) =
  (String.join ["? " nam])
(Show (Met nam None) dep) =
  "_"
(Show (Met nam (Some val)) dep) =
  (Show val dep)
(Show (Var nam idx) dep) =
  nam
(Show (Src src val) dep) =
  (Show val dep)

//(Show.many List.nil         dep) = ""
//(Show.many (List.cons x xs) dep) = (String.join [" " (Show x dep) (Show.many xs dep)])

(Show.trim (String.cons ' ' xs)) = xs
(Show.trim str)                  = str

(Show.unwrap (String.cons '(' xs)) = (Show.begin xs)
(Show.unwrap str)                  = str

(Show.begin (String.cons x (String.cons y String.nil))) = (String.cons x String.nil)
(Show.begin (String.cons x xs))                         = (String.cons x (Show.begin xs))
(Show.begin String.nil)                                 = String.nil

(Op2.show ADD) = "+"
(Op2.show SUB) = "-"
(Op2.show MUL) = "*"
(Op2.show DIV) = "/"
(Op2.show MOD) = "%"
(Op2.show EQ)  = "=="
(Op2.show NE)  = "!="
(Op2.show LT)  = "<"
(Op2.show GT)  = ">"
(Op2.show LTE) = "<="
(Op2.show GTE) = ">="
(Op2.show AND) = "&"
(Op2.show OR)  = "|"
(Op2.show XOR) = "^"
(Op2.show LSH) = "<<"
(Op2.show RSH) = ">>"

(Context.show List.nil         dep) = ""
(Context.show (List.cons x xs) dep) = (String.join [" " (Context.show.ann x dep) (Context.show xs dep)])

(Context.show.ann (Ann val typ) dep) = (String.join ["{" (Show (Normal 0 val dep) dep) ": " (Show (Normal 0 typ dep) dep) "}"])
(Context.show.ann term          dep) = (Show (Normal 0 term dep) dep)

(Message.show (Found name type ctx dep)) =
  let type  = (Show (Normal 1 type dep) dep)
  let ctx   = (String.tail (Context.show ctx dep))
  (String.join ["#found{" name " " type " [" ctx "]}"])
(Message.show (Error src detected expected value dep)) =
  let det = (Show (Normal 1 detected dep) dep)
  let exp = (Show (Normal 1 expected dep) dep)
  let val = (Show (Normal 0 value dep) dep)
  (String.join ["#error{" exp " " det " " val " " (U60.show src) "}"])
(Message.show (Solve name term dep)) =
  let term = (Show (Normal 1 term dep) dep)
  (String.join ["#solve{" name " "  term "}"])
(Message.show (Vague name)) =
  (String.join ["#vague{" name "}"])

// Compilation
// -----------

(Str.view str) = (str 0 λheadλtail(String.cons head (Str.view tail)) String.nil)

(Str.make (String.cons x xs)) = λP λcons λnil (cons x (Str.make xs))
(Str.make String.nil)         = λP λcons λnil nil

Compile.primitives = [
  (Pair "HVM.log" λA λB λmsg λret (HVM.log msg ret))
  (Pair "HVM.print" λA λmsg λret (HVM.print (Str.view msg) ret))
  (Pair "HVM.save" λA λname λdata λret (HVM.save (Str.view name) (Str.view data) ret))
  (Pair "HVM.load" λA λname λret (HVM.load (Str.view name) λdata (ret (Str.make data))))
]

(Compile (All nam inp bod)) = 0
(Compile (Lam nam bod))     = λx(Compile (bod (Var "" x)))
(Compile (App fun arg))     = ((Compile fun) (Compile arg))
(Compile (Ann val typ))     = (Compile val)
(Compile (Slf nam typ bod)) = 0
(Compile (Ins val))         = (Compile val)
(Compile (Ref nam sub val)) = (Compile.ref Compile.primitives nam val)
(Compile (Let nam val bod)) = (Compile (bod val))
(Compile Set)               = 0
(Compile U60)               = 0
(Compile (Num val))         = val
(Compile (Op2 opr fst snd)) = (Compile.op2 opr (Compile fst) (Compile snd))
(Compile (Mat nam x z s p)) = (Compile.mat (Compile x) (Compile z) λx(Compile (s (Var "" x))))
(Compile (Txt txt))         = (Str.make txt)
(Compile (Hol nam ctx))     = 0
(Compile (Var nam val))     = val
(Compile (Src src val))     = (Compile val)

//(Compile.txt (String.cons x xs)) = (App (App Book.String.cons (Num x)) (Compile.txt xs))
//(Compile.txt String.nil)         = Book.String.nil

(Compile.op2 ADD fst snd) = (+ fst snd)
(Compile.op2 SUB fst snd) = (- fst snd)
(Compile.op2 MUL fst snd) = (* fst snd)
(Compile.op2 DIV fst snd) = (/ fst snd)
(Compile.op2 MOD fst snd) = (% fst snd)
(Compile.op2 EQ  fst snd) = (== fst snd)
(Compile.op2 NE  fst snd) = (!= fst snd)
(Compile.op2 LT  fst snd) = (< fst snd)
(Compile.op2 GT  fst snd) = (> fst snd)
(Compile.op2 LTE fst snd) = (<= fst snd)
(Compile.op2 GTE fst snd) = (>= fst snd)
(Compile.op2 AND fst snd) = (& fst snd)
(Compile.op2 OR  fst snd) = (| fst snd)
(Compile.op2 XOR fst snd) = (^ fst snd)
(Compile.op2 LSH fst snd) = (<< fst snd)
(Compile.op2 RSH fst snd) = (>> fst snd)

(Compile.mat 0 z s) = z
(Compile.mat n z s) = (s (- n 1))

(Compile.ref (List.cons (Pair prim_name prim_func) prims) nam val) = (If (Same prim_name nam) prim_func (Compile.ref prims nam val))
(Compile.ref List.nil                                     nam val) = (Compile val)

// API
// ---

// Normalizes a definition.
(API.normal (Ref nam sub val)) =
  (Compile (Subst sub val))

// Checks a definition.
(API.check (Ref nam sub def)) =
  //(HVM.print (String.join ["API.check: " (Show (Subst sub def) 0)])
  (Result.match (Checker.run (API.check.do (Subst sub def)))
    // case done:
    λlogs λvalue
      //(API.check.log logs
      (Pair.get (API.check.fill sub logs) λfilled λsub
      (If filled
        // case true:
        (API.check (Ref nam sub def))
        // case false:
        (API.check.vague sub)))
    // case fail:
    λlogs λerror
      (API.check.log logs
      (API.check.log [error] 0)))

// Calls the type-checker *under* the metavar binders.
//(API.check.fn (List.cons _ subs) val) = λx (API.check.fn subs (val x))
//(API.check.fn List.nil           val) = (API.check.do val)

// Calls check on typed defs and infer on untyped defs.
(API.check.do (Ann val typ)) = (Check 0 val typ 0)
(API.check.do val)           = (Infer val 0)

// Moves solutions from the checker logs to a ref's subst list.
(API.check.fill sub (List.cons (Solve k v d) xs)) = (Pair.get (API.check.fill sub xs) λokλmap(Pair 1 (Map.set λxλy(Same x y) k (Some v) sub)))
(API.check.fill sub (List.cons message xs))       = (API.check.fill sub xs)
(API.check.fill sub List.nil)                     = (Pair 0 sub)

// Prints all messages returned by the checker.
(API.check.log (List.cons msg msgs) then) = (HVM.print (Message.show msg) (API.check.log msgs then))
(API.check.log List.nil             then) = then

// Reports solved holdes
(API.check.vague (List.cons (Pair name None)     xs)) = (HVM.print (Message.show (Vague name)) (& 0 (API.check.vague xs)))
(API.check.vague (List.cons (Pair name (Some x)) xs)) = (API.check.vague xs)
(API.check.vague List.nil)                            = 1

Book.BBT = (Ref "BBT" [] (Ann (Src 2199086170404 (Lam "K" λxK (Src 2199090364708 (Lam "V" λxV (Src 2199096656164 (Slf "self" (Src 2199105044567 (App (App (Src 2199106093138 (Book.BBT)) (Src 2199110287444 xK)) (Src 2199112384598 xV))) λxself (Src 2199118676260 (All "P" (Src 2199126016119 (All "bbt" (Src 2199135453300 (App (App (Src 2199136501871 (Book.BBT)) (Src 2199140696177 xK)) (Src 2199142793331 xV))) λxbbt (Src 2199146987639 (Set)))) λxP (Src 2199152230692 (All "bin" (Src 2199161667834 (All "size" (Src 2199172153490 (U60)) λxsize (Src 2199178445050 (All "key" (Src 2199187882142 xK) λxkey (Src 2199191027962 (All "val" (Src 2199200465066 xV) λxval (Src 2199203610874 (All "lft" (Src 2199213047998 (App (App (Src 2199214096569 (Book.BBT)) (Src 2199218290875 xK)) (Src 2199220388029 xV))) λxlft (Src 2199224582394 (All "rgt" (Src 2199234019538 (App (App (Src 2199235068109 (Book.BBT)) (Src 2199239262415 xK)) (Src 2199241359569 xV))) λxrgt (Src 2199245553914 (App (Src 2199246602454 xP) (Src 2199248699641 (App (App (App (App (App (App (App (Src 2199249748191 (Book.BBT.bin)) (Src 2199258136801 xK)) (Src 2199260233955 xV)) (Src 2199262331112 xsize)) (Src 2199267573996 xkey)) (Src 2199271768304 xval)) (Src 2199275962612 xlft)) (Src 2199280156920 xrgt))))))))))))))) λxbin (Src 2199289594148 (All "tip" (Src 2199299031320 (App (Src 2199300079881 xP) (Src 2199302177047 (App (App (Src 2199303225618 (Book.BBT.tip)) (Src 2199311614228 xK)) (Src 2199313711382 xV))))) λxtip (Src 2199321051428 (App (Src 2199322099998 xP) (Src 2199324197155 xself))))))))))))))) (Src 2199029547065 (All "K" (Src 2199036887054 (Set)) λxK (Src 2199054712889 (All "V" (Src 2199062052902 (Set)) λxV (Src 2199081975865 (Set))))))))
Book.BBT.bin = (Ref "BBT.bin" [] (Ann (Src 3298677489886 (Lam "K" λxK (Src 3298681684190 (Lam "V" λxV (Src 3298685878494 (Lam "size" λxsize (Src 3298693218526 (Lam "key" λxkey (Src 3298699509982 (Lam "val" λxval (Src 3298705801438 (Lam "lft" λxlft (Src 3298712092894 (Lam "rgt" λxrgt (Src 3298720481502 (Ins (Src 3298721530078 (Lam "P" λxP (Src 3298725724382 (Lam "bin" λxbin (Src 3298732015838 (Lam "tip" λxtip (Src 3298740404446 (App (App (App (App (App (Src 3298741453000 xbin) (Src 3298745647309 xsize)) (Src 3298750890193 xkey)) (Src 3298755084501 xval)) (Src 3298759278809 xlft)) (Src 3298763473117 xrgt))))))))))))))))))))))))) (Src 3298545369221 (All "K" (Src 3298552709138 (Set)) λxK (Src 3298557952133 (All "V" (Src 3298565292062 (Set)) λxV (Src 3298570535045 (All "size" (Src 3298581020720 (U60)) λxsize (Src 3298589409413 (All "key" (Src 3298598846526 xK) λxkey (Src 3298604089477 (All "val" (Src 3298613526604 xV) λxval (Src 3298618769541 (All "lft" (Src 3298628206690 (App (App (Src 3298629255261 (Book.BBT)) (Src 3298633449567 xK)) (Src 3298635546721 xV))) λxlft (Src 3298641838213 (All "rgt" (Src 3298651275384 (App (App (Src 3298652323955 (Book.BBT)) (Src 3298656518261 xK)) (Src 3298658615415 xV))) λxrgt (Src 3298664906885 (App (App (Src 3298665955456 (Book.BBT)) (Src 3298670149762 xK)) (Src 3298672246916 xV)))))))))))))))))))
Book.BBT.has.linear = (Ref "BBT.has.linear" [] (Ann (Src 1099750704440 (Lam "K" λxK (Src 1099754898744 (Lam "V" λxV (Src 1099759093048 (Lam "cmp" λxcmp (Src 1099765384504 (Lam "key" λxkey (Src 1099771675960 (Lam "map" λxmap (Src 1099780064568 (Let "P" (Src 1099788452128 (Lam "x" λxx (Src 1099791597856 (App (App (Src 1099792646416 (Book.Pair)) (Src 1099797889301 (Book.Bool))) (Src 1099803132191 (App (App (Src 1099804180762 (Book.BBT)) (Src 1099808375068 xK)) (Src 1099810472222 xV))))))) λxP (Src 1099816764728 (Let "bin" (Src 1099827250405 (Lam "size" λxsize (Src 1099834590437 (Lam "node_key" λxnode_key (Src 1099846124773 (Lam "val" λxval (Src 1099852416229 (Lam "lft" λxlft (Src 1099858707685 (Lam "rgt" λxrgt (Src 1099869193445 (Let "P" (Src 1099877581260 (Lam "x" λxx (Src 1099881775564 (All "cmp" (Src 1099891212673 (All "a" (Src 1099898552690 xK) λxa (Src 1099901698433 (All "b" (Src 1099909038460 xK) λxb (Src 1099912184193 (Book.Cmp)))))) λxcmp (Src 1099917427148 (All "key" (Src 1099926864269 xK) λxkey (Src 1099930010060 (All "lft" (Src 1099939447201 (App (App (Src 1099940495772 (Book.BBT)) (Src 1099944690078 xK)) (Src 1099946787232 xV))) λxlft (Src 1099950981580 (All "rgt" (Src 1099960418741 (App (App (Src 1099961467312 (Book.BBT)) (Src 1099965661618 xK)) (Src 1099967758772 xV))) λxrgt (Src 1099971953100 (App (App (Src 1099973001660 (Book.Pair)) (Src 1099978244545 (Book.Bool))) (Src 1099983487435 (App (App (Src 1099984536006 (Book.BBT)) (Src 1099988730312 xK)) (Src 1099990827466 xV))))))))))))))) λxP (Src 1099999216869 (Let "ltn" (Src 1100009702124 (Lam "cmp" λxcmp (Src 1100015993580 (Lam "size" λxsize (Src 1100023333612 (Lam "has_key" λxhas_key (Src 1100033819372 (Lam "val" λxval (Src 1100040110828 (Lam "lft" λxlft (Src 1100046402284 (Lam "rgt" λxrgt (Src 1100052693740 (Lam "has_key" λxhas_key (Src 1100069470956 (Let "P" (Src 1100077859381 (Lam "x" λxx (Src 1100082053685 (App (App (Src 1100083102245 (Book.Pair)) (Src 1100088345130 (Book.Bool))) (Src 1100093588020 (App (App (Src 1100094636591 (Book.BBT)) (Src 1100098830897 xK)) (Src 1100100928051 xV))))))) λxP (Src 1100111413996 (Let "new" (Src 1100121899704 (Lam "bool" λxbool (Src 1100129239736 (Lam "lft" λxlft (Src 1100144968376 (Let "map" (Src 1100155454093 (App (App (App (App (App (App (App (Src 1100156502638 (Book.BBT.bin)) (Src 1100164891248 xK)) (Src 1100166988402 xV)) (Src 1100169085559 xsize)) (Src 1100174328448 xnode_key)) (Src 1100183765636 xval)) (Src 1100187959944 xlft)) (Src 1100192154252 xrgt))) λxmap (Src 1100205785784 (App (App (App (App (Src 1100206834335 (Book.Pair.new)) (Src 1100216271524 (Book.Bool))) (Src 1100221514414 (App (App (Src 1100222562985 (Book.BBT)) (Src 1100226757291 xK)) (Src 1100228854445 xV)))) (Src 1100232000179 xbool)) (Src 1100237243063 xmap))))))))) λxnew (Src 1100248777452 (App (App (Src 1100249826021 (Ins (Src 1100250874597 (App (App (App (App (App (Src 1100251923152 (Book.BBT.has.linear)) (Src 1100267651794 xK)) (Src 1100269748948 xV)) (Src 1100271846104 xcmp)) (Src 1100276040416 xhas_key)) (Src 1100284429028 xlft))))) (Src 1100289671911 xP)) (Src 1100291769067 xnew))))))))))))))))))))) λxltn (Src 1100301206757 (Let "eql" (Src 1100311692155 (Lam "cmp" λxcmp (Src 1100317983611 (Lam "size" λxsize (Src 1100325323643 (Lam "key" λxkey (Src 1100331615099 (Lam "val" λxval (Src 1100337906555 (Lam "lft" λxlft (Src 1100344198011 (Lam "rgt" λxrgt (Src 1100350489467 (Lam "has_key" λxhas_key (Src 1100367266683 (App (App (App (App (Src 1100368315193 (Book.Pair.new)) (Src 1100377752382 (Book.Bool))) (Src 1100382995272 (App (App (Src 1100384043843 (Book.BBT)) (Src 1100388238149 xK)) (Src 1100390335303 xV)))) (Src 1100393481042 (Book.Bool.true))) (Src 1100403966842 (App (App (App (App (App (App (App (Src 1100405015387 (Book.BBT.bin)) (Src 1100413403997 xK)) (Src 1100415501151 xV)) (Src 1100417598308 xsize)) (Src 1100422841197 xnode_key)) (Src 1100432278385 xval)) (Src 1100436472693 xlft)) (Src 1100440667001 xrgt))))))))))))))))))) λxeql (Src 1100452201701 (Let "gtn" (Src 1100462687384 (Lam "cmp" λxcmp (Src 1100468978840 (Lam "size" λxsize (Src 1100476318872 (Lam "key" λxkey (Src 1100482610328 (Lam "val" λxval (Src 1100488901784 (Lam "lft" λxlft (Src 1100495193240 (Lam "rgt" λxrgt (Src 1100501484696 (Lam "has_key" λxhas_key (Src 1100518261912 (Let "P" (Src 1100526650337 (Lam "x" λxx (Src 1100530844641 (App (App (Src 1100531893201 (Book.Pair)) (Src 1100537136086 (Book.Bool))) (Src 1100542378976 (App (App (Src 1100543427547 (Book.BBT)) (Src 1100547621853 xK)) (Src 1100549719007 xV))))))) λxP (Src 1100560204952 (Let "new" (Src 1100570690660 (Lam "bool" λxbool (Src 1100578030692 (Lam "rgt" λxrgt (Src 1100593759332 (Let "map" (Src 1100604245049 (App (App (App (App (App (App (App (Src 1100605293594 (Book.BBT.bin)) (Src 1100613682204 xK)) (Src 1100615779358 xV)) (Src 1100617876515 xsize)) (Src 1100623119404 xnode_key)) (Src 1100632556592 xval)) (Src 1100636750900 xlft)) (Src 1100640945208 xrgt))) λxmap (Src 1100654576740 (App (App (App (App (Src 1100655625291 (Book.Pair.new)) (Src 1100665062480 (Book.Bool))) (Src 1100670305370 (App (App (Src 1100671353941 (Book.BBT)) (Src 1100675548247 xK)) (Src 1100677645401 xV)))) (Src 1100680791135 xbool)) (Src 1100686034019 xrgt))))))))) λxnew (Src 1100697568408 (App (App (Src 1100698616977 (Ins (Src 1100699665553 (App (App (App (App (App (Src 1100700714108 (Book.BBT.has.linear)) (Src 1100716442750 xK)) (Src 1100718539904 xV)) (Src 1100720637060 xcmp)) (Src 1100724831372 xhas_key)) (Src 1100733219984 xrgt))))) (Src 1100738462867 xP)) (Src 1100740560023 xnew))))))))))))))))))))) λxgtn (Src 1100751045861 (App (App (App (App (App (App (App (Src 1100752094402 (App (App (App (App (Src 1100753142963 (Ins (Src 1100754191539 (App (App (Src 1100755240101 xcmp) (Src 1100759434409 xkey)) (Src 1100763628722 xnode_key))))) (Src 1100774114485 xP)) (Src 1100776211641 xltn)) (Src 1100780405949 xeql)) (Src 1100784600257 xgtn))) (Src 1100789843142 xcmp)) (Src 1100794037451 xsize)) (Src 1100799280340 xnode_key)) (Src 1100808717528 xval)) (Src 1100812911836 xlft)) (Src 1100817106144 xrgt)) (Src 1100821300452 xkey))))))))))))))))))))) λxbin (Src 1100829689144 (Let "tip" (Src 1100840174885 (App (App (App (App (Src 1100841223420 (Book.Pair.new)) (Src 1100850660609 (Book.Bool))) (Src 1100855903499 (App (App (Src 1100856952070 (Book.BBT)) (Src 1100861146376 xK)) (Src 1100863243530 xV)))) (Src 1100866389270 (Book.Bool.false))) (Src 1100877923620 (App (App (Src 1100878972191 (Book.BBT.tip)) (Src 1100887360801 xK)) (Src 1100889457955 xV))))) λxtip (Src 1100895749432 (App (App (App (Src 1100896797997 (Ins (Src 1100897846573 xmap))) (Src 1100902040879 xP)) (Src 1100904138035 xbin)) (Src 1100908332343 xtip))))))))))))))))))) (Src 1099624874209 (All "K" (Src 1099632214132 (Set)) λxK (Src 1099637457121 (All "V" (Src 1099644797056 (Set)) λxV (Src 1099650040033 (All "cmp" (Src 1099659477156 (All "a" (Src 1099666817173 xK) λxa (Src 1099669962916 (All "b" (Src 1099677302943 xK) λxb (Src 1099680448676 (Book.Cmp)))))) λxcmp (Src 1099687788769 (All "key" (Src 1099697225906 xK) λxkey (Src 1099702468833 (All "map" (Src 1099711905992 (App (App (Src 1099712954563 (Book.BBT)) (Src 1099717148869 xK)) (Src 1099719246023 xV))) λxmap (Src 1099725537505 (App (App (Src 1099726586065 (Book.Pair)) (Src 1099731828950 (Book.Bool))) (Src 1099737071840 (App (App (Src 1099738120411 (Book.BBT)) (Src 1099742314717 xK)) (Src 1099744411871 xV)))))))))))))))))
Book.BBT.tip = (Ref "BBT.tip" [] (Ann (Src 4398094745678 (Lam "K" λxK (Src 4398098939982 (Lam "V" λxV (Src 4398105231438 (Ins (Src 4398106280014 (Lam "P" λxP (Src 4398110474318 (Lam "bin" λxbin (Src 4398116765774 (Lam "tip" λxtip (Src 4398125154382 xtip))))))))))))) (Src 4398056996907 (All "K" (Src 4398064336914 (Set)) λxK (Src 4398069579819 (All "V" (Src 4398076919838 (Set)) λxV (Src 4398082162731 (App (App (Src 4398083211302 (Book.BBT)) (Src 4398087405608 xK)) (Src 4398089502762 xV)))))))))
Book.Bool = (Ref "Bool" [] (Ann (Src 5497569673325 (Slf "self" (Src 5497578061847 (Book.Bool)) λxself (Src 5497586450541 (All "P" (Src 5497593790512 (All "x" (Src 5497601130541 (Book.Bool)) λxx (Src 5497607422000 (Set)))) λxP (Src 5497612664941 (All "t" (Src 5497620004936 (App (Src 5497621053501 xP) (Src 5497623150663 (Book.Bool.true)))) λxt (Src 5497637830765 (All "f" (Src 5497645170785 (App (Src 5497646219349 xP) (Src 5497648316512 (Book.Bool.false)))) λxf (Src 5497664045165 (App (Src 5497665093735 xP) (Src 5497667190892 xself))))))))))) (Src 5497565478920 (Set))))
Book.Bool.false = (Ref "Bool.false" [] (Ann (Src 6597090738210 (Ins (Src 6597091786786 (Lam "P" λxP (Src 6597095981090 (Lam "t" λxt (Src 6597100175394 (Lam "f" λxf (Src 6597104369698 xf))))))))) (Src 6597083398161 (Book.Bool))))
Book.Bool.true = (Ref "Bool.true" [] (Ann (Src 7696601317409 (Ins (Src 7696602365985 (Lam "P" λxP (Src 7696606560289 (Lam "t" λxt (Src 7696610754593 (Lam "f" λxf (Src 7696614948897 xt))))))))) (Src 7696593977360 (Book.Bool))))
Book.Char = (Ref "Char" [] (Ann (Src 16492685950991 (U60)) (Src 16492681756680 (Set))))
Book.Cmp = (Ref "Cmp" [] (Ann (Src 8796103508099 (Slf "self" (Src 8796111896597 (Book.Cmp)) λxself (Src 8796119236739 (All "P" (Src 8796126576687 (All "cmp" (Src 8796136013868 (Book.Cmp)) λxcmp (Src 8796141256751 (Set)))) λxP (Src 8796146499715 (All "ltn" (Src 8796155936839 (App (Src 8796156985406 xP) (Src 8796159082566 (Book.Cmp.ltn)))) λxltn (Src 8796171665539 (All "eql" (Src 8796181102687 (App (Src 8796182151254 xP) (Src 8796184248414 (Book.Cmp.eql)))) λxeql (Src 8796196831363 (All "gtn" (Src 8796206268535 (App (Src 8796207317102 xP) (Src 8796209414262 (Book.Cmp.gtn)))) λxgtn (Src 8796221997187 (App (Src 8796223045757 xP) (Src 8796225142914 xself))))))))))))) (Src 8796099313671 (Set))))
Book.Cmp.eql = (Ref "Cmp.eql" [] (Ann (Src 9895621427244 (Ins (Src 9895622475820 (Lam "P" λxP (Src 9895626670124 (Lam "ltn" λxltn (Src 9895632961580 (Lam "eql" λxeql (Src 9895639253036 (Lam "gtn" λxgtn (Src 9895647641644 xeql))))))))))) (Src 9895615135757 (Book.Cmp))))
Book.Cmp.gtn = (Ref "Cmp.gtn" [] (Ann (Src 10995133055020 (Ins (Src 10995134103596 (Lam "P" λxP (Src 10995138297900 (Lam "ltn" λxltn (Src 10995144589356 (Lam "eql" λxeql (Src 10995150880812 (Lam "gtn" λxgtn (Src 10995159269420 xgtn))))))))))) (Src 10995126763533 (Book.Cmp))))
Book.Cmp.ltn = (Ref "Cmp.ltn" [] (Ann (Src 12094644682796 (Ins (Src 12094645731372 (Lam "P" λxP (Src 12094649925676 (Lam "ltn" λxltn (Src 12094656217132 (Lam "eql" λxeql (Src 12094662508588 (Lam "gtn" λxgtn (Src 12094670897196 xltn))))))))))) (Src 12094638391309 (Book.Cmp))))
Book.List = (Ref "List" [] (Ann (Src 17592210161854 (Lam "T" λxT (Src 17592216453310 (Slf "self" (Src 17592224841773 (App (Src 17592225890346 (Book.List)) (Src 17592231133228 xT))) λxself (Src 17592237424830 (All "P" (Src 17592244764747 (All "xs" (Src 17592253153352 (App (Src 17592254201925 (Book.List)) (Src 17592259444807 xT))) λxxs (Src 17592263639115 (Set)))) λxP (Src 17592268882110 (All "cons" (Src 17592279367829 (All "head" (Src 17592289853540 xT) λxhead (Src 17592292999317 (All "tail" (Src 17592303485048 (App (Src 17592304533621 (Book.List)) (Src 17592309776503 xT))) λxtail (Src 17592313970837 (App (Src 17592315019388 xP) (Src 17592317116564 (App (App (App (Src 17592318165127 (Book.List.cons)) (Src 17592328650889 xT)) (Src 17592330748046 xhead)) (Src 17592335990931 xtail))))))))) λxcons (Src 17592346476734 (All "nil" (Src 17592355913906 (App (Src 17592356962468 xP) (Src 17592359059633 (App (Src 17592360108206 (Book.List.nil)) (Src 17592369545392 xT))))) λxnil (Src 17592376885438 (App (Src 17592377934008 xP) (Src 17592380031165 xself))))))))))))) (Src 17592193384468 (All "T" (Src 17592200724495 (Set)) λxT (Src 17592205967380 (Set))))))
Book.List.cons = (Ref "List.cons" [] (Ann (Src 18691773169792 (Lam "T" λxT (Src 18691777364096 (Lam "head" λxhead (Src 18691784704128 (Lam "tail" λxtail (Src 18691794141312 (Ins (Src 18691795189888 (Lam "P" λxP (Src 18691799384192 (Lam "cons" λxcons (Src 18691806724224 (Lam "nil" λxnil (Src 18691815112832 (App (App (Src 18691816161397 xcons) (Src 18691821404282 xhead)) (Src 18691826647167 xtail))))))))))))))))) (Src 18691710255173 (All "T" (Src 18691717595156 (Set)) λxT (Src 18691722838085 (All "head" (Src 18691733323811 xT) λxhead (Src 18691738566725 (All "tail" (Src 18691749052473 (App (Src 18691750101046 (Book.List)) (Src 18691755343928 xT))) λxtail (Src 18691761635397 (App (Src 18691762683970 (Book.List)) (Src 18691767926852 xT)))))))))))
Book.List.nil = (Ref "List.nil" [] (Ann (Src 19791244951615 (Lam "T" λxT (Src 19791251243071 (Ins (Src 19791252291647 (Lam "P" λxP (Src 19791256485951 (Lam "cons" λxcons (Src 19791263825983 (Lam "nil" λxnil (Src 19791272214591 xnil))))))))))) (Src 19791220834335 (All "T" (Src 19791228174355 (Set)) λxT (Src 19791233417247 (App (Src 19791234465820 (Book.List)) (Src 19791239708702 xT)))))))
Book.Pair = (Ref "Pair" [] (Ann (Src 13194176233644 (Lam "A" λxA (Src 13194180427948 (Lam "B" λxB (Src 13194186719404 (Slf "self" (Src 13194195107903 (App (App (Src 13194196156474 (Book.Pair)) (Src 13194201399356 xA)) (Src 13194203496510 xB))) λxself (Src 13194209788076 (All "P" (Src 13194217128033 (All "pair" (Src 13194227613790 (App (App (Src 13194228662361 (Book.Pair)) (Src 13194233905243 xA)) (Src 13194236002397 xB))) λxpair (Src 13194240196705 (Set)))) λxP (Src 13194245439660 (All "new" (Src 13194254876832 (All "fst" (Src 13194264313976 xA) λxfst (Src 13194267459744 (All "snd" (Src 13194276896900 xB) λxsnd (Src 13194280042656 (App (Src 13194281091208 xP) (Src 13194283188383 (App (App (App (App (Src 13194284236946 (Book.Pair.new)) (Src 13194293674132 xA)) (Src 13194295771286 xB)) (Src 13194297868442 xfst)) (Src 13194302062750 xsnd))))))))) λxnew (Src 13194311499948 (App (Src 13194312548518 xP) (Src 13194314645675 xself))))))))))))) (Src 13194146873376 (All "A" (Src 13194154213391 (Set)) λxA (Src 13194159456288 (All "B" (Src 13194166796315 (Set)) λxB (Src 13194172039200 (Set))))))))
Book.Pair.new = (Ref "Pair.new" [] (Ann (Src 14293726658670 (Lam "A" λxA (Src 14293730852974 (Lam "B" λxB (Src 14293735047278 (Lam "a" λxa (Src 14293739241582 (Lam "b" λxb (Src 14293745533038 (Ins (Src 14293746581614 (Lam "P" λxP (Src 14293750775918 (Lam "new" λxnew (Src 14293757067374 (App (App (Src 14293758115945 xnew) (Src 14293762310251 xa)) (Src 14293764407405 xb))))))))))))))))) (Src 14293662695493 (All "A" (Src 14293670035475 (Set)) λxA (Src 14293675278405 (All "B" (Src 14293682618399 (Set)) λxB (Src 14293687861317 (All "a" (Src 14293695201323 xA) λxa (Src 14293700444229 (All "b" (Src 14293707784247 xB) λxb (Src 14293713027141 (App (App (Src 14293714075712 (Book.Pair)) (Src 14293719318594 xA)) (Src 14293721415748 xB)))))))))))))
Book.String = (Ref "String" [] (Ann (Src 15393176420376 (App (Src 15393177468946 (Book.List)) (Src 15393182711831 (Book.Char)))) (Src 15393172226058 (Set))))
Book.String.cons = (Ref "String.cons" [] (Ann (Src 20890784890993 (Lam "head" λxhead (Src 20890792231025 (Lam "tail" λxtail (Src 20890801668209 (Ins (Src 20890802716785 (Lam "P" λxP (Src 20890806911089 (Lam "cons" λxcons (Src 20890814251121 (Lam "nil" λxnil (Src 20890822639729 (App (App (Src 20890823688294 xcons) (Src 20890828931179 xhead)) (Src 20890834174064 xtail))))))))))))))) (Src 20890735607866 (All "head" (Src 20890746093596 (Book.Char)) λxhead (Src 20890754482234 (All "tail" (Src 20890764967984 (Book.String)) λxtail (Src 20890775453754 (Book.String))))))))
Book.String.nil = (Ref "String.nil" [] (Ann (Src 21990255624237 (Ins (Src 21990256672813 (Lam "P" λxP (Src 21990260867117 (Lam "cons" λxcons (Src 21990268207149 (Lam "nil" λxnil (Src 21990276595757 xnil))))))))) (Src 21990246187027 (Book.String))))

Main = (API.check Book.BBT.has.linear)
