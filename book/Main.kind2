//CON = String.concat

//Main = Parser.skip

Main = Kind.compile.hvm.book.go

//Main = Kind.Book.parser
//Main = Parser.is_eof
//Main = U60.Map.set

//Main = (String.skip "//oimeugrandeamigo... tudo bem?
//eu to, e vc?
//fofo
//")

//Main = Parser.text
//Main
//: String
//= let term = (Kind.Term.parser.run "
    //λf λx (f (f x))
  //")
  //(Kind.compile.hvm term Nat.zero)



//Main
//: String
//= let CON   = String.concat
  //let P     = λx(String)
  //let done  = λcode λvalue (CON "done: " (CON code (CON " ## RESULT={{" (CON value "}}"))))
  //let fail  = λcode λvalue (CON "fail: " code)
  //let parse = (Parser.until Char (Parser.text "ABC") Parser.take)
  ////let parse = (Parser.bind Unit String (Parser.text "ABC") λx(Parser.pure String "ok"))
  //(~(parse "oi tudo bem bar aaaaaaaa    tic tac") P done fail)

//Main = Parser.until

//Main
//: String
//= let CON  = String.concat
  //let parse = (Parser.char.escaped 'n' #32)
  //let P    = λx(String)
  //let done = λcode λvalue (CON code (CON " || " (String.cons value String.nil)))
  //let fail = λcode λvalue "fail"
  //(~(parse "\nfoo") P done fail)

//Main = Parser.char

//Main 
//: String
//= let OPT  = (List.cons (Parser String))
  //let END  = (List.nil (Parser String))
  //let CON  = String.concat
  //let P    = λx(String)
  //let done = λcode λvalue (CON "done: " (CON (String.cons value String.nil) (CON " ## left: " code)))
  //let fail = λcode λvalue (CON "fail: " code)
  //(~(Parser.char "\\bc") P done fail)

//Main = Parser.until
//Main = Char.escapes
//Main = Kind.Term.parser
//Main = Kind.Scope.find

//Main = List.fold

//Main
//: (List.Folder #U60)
//= λP λcons λnil (cons #0 (cons #1 (cons #2 nil)))

//Main
//: #U60
//= let list =
    //(List.cons #U60 #1 
    //(List.cons #U60 #2
    //(List.cons #U60 #3 
    //(List.nil #U60))))
  //((List.fold #U60 list) #U60 λhλt#(+ h t) #0)


//Main
//: String
//= let OPT  = (List.cons (Parser String))
  //let END  = (List.nil (Parser String))
  //let CON  = String.concat
  //let NIL  = String.nil
  //let P    = λx(String)
  //let done = λcode λvalue (CON "done: " (CON value (CON " ## left: " code)))
  //let fail = λcode λerror (CON "fail: " code)
  //let opts =
    //(OPT (Parser.bind Unit String (Parser.text (String.cons Char.slash (String.cons 'n' String.nil))) λx
         //(Parser.pure String "parsed_0"))
    //(OPT (Parser.bind Unit String (Parser.text "farinha") λx
         //(Parser.pure String "parsed_1"))
    //(OPT (Parser.bind Unit String (Parser.text "alpiste") λx
         //(Parser.pure String "parsed_2"))
    //END))) 
  //let text = "\nalpiste medula oblongata"
  //(~(Parser.options String opts text) P done fail)

//Main
//: String
//= let P    = λx(String)
  //let done = λcode λvalue (CON "done: " (CON (Bool.if value String "Y" "N") (CON " ## left: " code)))
  //let fail = λerror (CON "fail: " error)
  //(~(Parser.test "testador de" "testador de testes") P done fail)

//Main
//: String
//= let P   = λx(String)
  //let new = λcode λword word
  //(~(Parser.word Char.is_name "foo bar tic tac") P new)

//Main
//: Bool
//= (Char.is_name 'D')

//Main
//: String
//= (String.cons 'a' String.nil)

//Main
//: String
//= let str = "    foo bar"
  //(String.skip str)

//Main
//: (Maybe #U60)
//= let list =
    //(List.cons #U60 #10
    //(List.cons #U60 #20
    //(List.cons #U60 #30
    //(List.cons #U60 #40
    //(List.cons #U60 #50
    //(List.nil #U60))))))
  //(List.find #U60 (U60.equal #30) list)

//Main
//: Bool
//= (String.equal "abcd" "abcd")

//Main
//: String
//= (U60.name #703)

//Main
//: String
//= #match x = #2 {
  //#0: "0"
  //#+: #match y = x-1 {
    //#0: "1"
    //#+: ">"
  //}: String
//}: String
